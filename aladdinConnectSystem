/*

Copyright 2020 - tomw

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Change history:

2.0.0(dev) - tomw - Update to new API flow

 */

metadata
{
    definition(name: "Aladdin Connect System", namespace: "tomw", author: "tomw", importUrl: "")
    {
        capability "Actuator"
        capability "Configuration"
        capability "Initialize"
        capability "Refresh"
        
        attribute "commStatus", "string"
        
        command "connectWSS"
    }
}

preferences
{
    section
    {
        input name: "username", type: "text", title: "Username (email)", required: true
        input name: "password", type: "password", title: "Password", required: true
        input name: "refreshInterval", type: "number", title: "Refresh interval", defaultValue: 5
        input name: "refreshIntervalS", type: "bool", title: "Use seconds for refresh interval? (false for minutes)", defaultValue: false 
        input name: "logEnable", type: "bool", title: "Enable debug logging", defaultValue: false
    }
}

def logDebug(msg) 
{
    if (logEnable)
    {
        log.debug(msg)
    }
}

def connectWSS()
{
    def url = "wss://event-caster.st1.gdocntl.net/updates"
    def headers =
        [
            Authorization: "Bearer ${getToken()}"
        ]
    
    interfaces.webSocket.connect(url, headers: headers, ignoreSSLIssues: true)
}

def webSocketStatus(String message)
{
    logDebug("webSocketStatus: ${message}")
}

def parse(String message)
{
    logDebug("parse: ${message}")
    
    // message = '{"serial":"F0AD4E0F20B3","door":1,"door_status":1}'
    
    try
    {
        def event = new groovy.json.JsonSlurper().parseText(message)
        def door = [legacy_id: event.serial, door_number: event.door]
        
        manageDoorDevice(door)?.handleEvent(event)
    }
    catch(Exception e)
    {
        log.debug "Unrecognized message: ${message}"
    }    
}

def updated()
{
    configure()
}

def configure()
{
    state.clear()    
    initialize()
}

def initialize()
{
    sendEvent(name: "commStatus", value: "unknown") 
    refresh()
}

def refresh()
{
    unschedule()
    
    try
    {
        refreshDoorInfo()
        // TODO: signal strength
    }
    catch (Exception e)
    {
        logDebug("refresh() failed")
    }
    
    // schedule next refresh
    runIn(refreshPeriod(), refresh)
}

def login()
{
    def body = 
    [
        grant_type: "password",
        client_id: "1000",
        brand: "ALADDIN",
        username: java.net.URLEncoder.encode(username, "UTF-8"),
        password: password.getBytes("UTF-8").encodeBase64().toString(),        
        platform: "platform",
        app_version: "5.25",
        build_number: "2038",
        os_version: "12.0.0"
    ]
    
    def resp = httpAccess("POST", (genParamsApi("oauth/token", "text", body)))
    
    if(resp)
    {
        setToken(resp.data.access_token)
    }
}

def get_devices()
{
    def resp = httpAccess("GET", genParamsApi("configuration", "text"))
    
    if(resp)
    {
        def doors = []
        
        for(device in resp.data.devices)
        {
            logDebug device            
            for(door in device.doors)
            {
                thisDoor = 
                    [
                        legacy_id: device.legacy_id?.toString(),
                        device_id: device.id,
                        door_number: door.door_index,
                        name: door.name,
                        status: door.status,
                        link_status: door.link_status,
                        ble_strength: door.ble_strength,
                        battery_level: door.battery_level
                    ]
                
                doors += thisDoor                    
                manageDoorDevice(thisDoor)?.refreshFromMaster(thisDoor)
            }
        }
        
        setDevices(doors)
    }    
}

def refreshDoorInfo()
{
    try
    {
        get_devices()
        return
    }
    catch (Exception e)
    {
        if(e.getResponse()?.getStatus()?.toInteger() == 401)
        {
            login()
            get_devices()
        }
        
        logDebug("refreshDoorInfo() failed")
        sendEvent(name: "commStatus", value: "error")
        throw(e)
    }
}

def operateDoor(deviceID, doorNum, op)
{
    payload = [command_key: (op == "open") ? "OpenDoor" : "CloseDoor"]
    
    httpAccess("POST", genParamsApi("devices/${deviceID}/door/${doorNum}/command", "json", payload))
}

def operateDoor(ch, op)
{
    if(ch)
    {
        def details = ch.getDeviceNetworkId().split('-')
        def deviceID = ch.getDataValue("device_id")
        operateDoor(deviceID, details?.getAt(1), op)
    }
}

void componentClose(ch)
{
    operateDoor(ch, "close")
}

void componentOpen(ch)
{
    operateDoor(ch, "open")
}

def refreshPeriod()
{
    def basePeriod = refreshInterval.toFloat().toInteger()
    
    return refreshIntervalS ? basePeriod : basePeriod * 60
}

def refreshFromChild()
{
    unschedule()
    refreshDoorInfo()
    
    // schedule next refresh
    runIn(refreshPeriod(), refresh)
}

def setToken(token)
{
    state.token = token
}

def getToken()
{
    return state.token
}

def setDevices(devices)
{
    state.devices = devices
}

def getDevices()
{
    return state.devices
}

def manageDoorDevice(door)
{
    // use existing child, or create it
    def child = 
        getChildDevice(childDoorName(door)) ?: 
        addChildDevice("Aladdin Connect Garage Door", childDoorName(door), [label:door.name, isComponent:false, name:"${childDoorName(door)}"])
}

def childDoorName(door)
{
    return "${door.legacy_id}-${door.door_number}"
}

String toQueryString(Map m)
{
    return m.collect{ k, v -> "${k}=${v.toString()}" }.sort().join("&")
}

def getAWSURI()
{
    return "https://pxdqkls7aj.execute-api.us-east-1.amazonaws.com/Android"
}

def genParamsApi(endpoint, type, body = null)
{
    def params =
        [
            uri: getAWSURI() + "/" + endpoint,
            headers:
            [
                AppVersion: '5.25',
                BundleName: 'com.geniecompany.AladdinConnect',
                'User-Agent': 'okhttp/3.12.1',
                'BuildVersion': '131',
                'X-Api-Key': 'fkowarQ0dX9Gj1cbB9Xkx1yXZkd6bzVn5x24sECW',
                'Content-Type': (type == "text") ? 'application/x-www-form-urlencoded' : 'application/json',
                Authorization: "Bearer ${getToken()}"
            ],
            
            requestContentType: (type == "text") ? 'application/x-www-form-urlencoded' : 'application/json',
        ]
    
    if(body)
    {
        switch(type)
        {
            case "text":
                params.body = toQueryString(body)
                break
            
            case "json":
                params.body = new groovy.json.JsonOutput().toJson(body)
                break
        }
    }
 
    return params
}

def httpAccess(op, params)
{    
    def result = null
    
    logDebug("httpAccess(${op}, ${params})")
    
    def httpClosure = 
    { resp ->
        result = resp
        logDebug("result.data = ${result.data}")
    }  
    
    switch(op)
    {
        case "POST":
            httpPost(params, httpClosure)
            break
        case "GET":
            httpGet(params, httpClosure)
            break
    }
    
    return result
}
